# План реализации пересборки модулей (с учетом текущей архитектуры)

Этот документ — практический план внедрения **WordPress/NodeBB‑стиля** для
модулей RusToK, где **install/uninstall = изменение манифеста → rebuild →
deploy**. План учитывает текущую архитектуру: модульный реестр формируется на
старте сервера, модули — Rust‑crates, а приложение уже содержит админ‑интерфейсы
(`apps/admin`, `apps/next-admin`).

## 0) Текущие реалии (от чего отталкиваемся)

- **Модули компилируются в бинарник**, а `ModuleRegistry` строится при старте
  сервера. Это означает, что установка “нового” модуля без сборки невозможна —
  требуется новый артефакт сборки.
- **Включение/выключение** модуля на tenant‑уровне уже решено через
  `tenant_modules` и `toggle_module` (runtime‑логика), но это не меняет набор
  модулей в бинарнике.
- Уже есть документация по **манифесту** и **admin rebuild blueprint** —
  это основа для формализации процесса пересборки и API‑интеграций.

## 1) Цели внедрения (что должно работать)

1. **Install/uninstall через админку**: админ изменяет список модулей,
   запускает сборку, видит статус и может откатиться.
2. **Источник правды** — `modules.toml` (или иной manifest), зафиксированный
   в репозитории/артефакте сборки.
3. **Сборка и деплой** происходят автоматически и воспроизводимо.
4. **Никакой runtime‑подгрузки нативного кода**, только пересборка.

## 2) Предлагаемая дорожная карта

### Этап A — Формализовать манифест и связать его с кодом

**Цель:** чтобы набор модулей *фактически* определялся манифестом.

Задачи:
1. **Выбрать файл манифеста** (например, `modules.toml`) и утвердить схему
   на уровне команды (ссылаться на спецификацию).
2. **Автоматизировать сборку реестра**:
   - добавить `xtask`/`build.rs`/скрипт, который генерирует код регистрации
     модулей на основе манифеста (например, `apps/server/src/modules/generated.rs`).
   - `build_registry()` импортирует сгенерированный список вместо
     “ручной” регистрации.
3. **Проверка на этапе CI**: если манифест изменился, а сгенерированный код
   не обновлён — билд должен падать.

Результат: **манифест становится единственным источником набора модулей.**

### Этап B — Минимальный Build‑Service (без админки)

**Цель:** дать команде способ запускать rebuild без UI, но с логами и статусом.

Задачи:
1. **Сервис‑обёртка** (отдельный сервис или job runner), который:
   - принимает `modules.toml` (или ссылку на git‑коммит),
   - запускает сборку,
   - публикует артефакт/образ,
   - сохраняет статус/логи.
2. **Минимальная модель данных** (таблица `builds` или внешнее хранилище):
   - `build_id`, `status`, `manifest_hash`, `started_at`, `finished_at`,
     `logs_url`, `release_id`.
3. **CLI/HTTP API** для запуска и статуса (достаточно пары эндпойнтов,
   как в blueprint).

Результат: **сборку можно запускать вручную/скриптом**, не дожидаясь UI.

### Этап C — Интеграция с админкой (NodeBB‑подобный UX)

**Цель:** UI‑кнопка “Install/Uninstall” с прогрессом сборки и деплоя.

Задачи:
1. **Admin API** (в `apps/server`) для:
   - создания rebuild‑задачи,
   - чтения статуса,
   - запуска deploy/rollback.
2. **UI в админке** (`apps/admin` или `apps/next-admin`):
   - управление списком модулей (manifest),
   - модальное окно статуса сборки,
   - история сборок/релизов.
3. **RBAC**: только админы/суперадмины могут запускать rebuild.

Результат: **полный “NodeBB‑подобный” опыт** — управляемые пересборки из UI.

### Этап D — Надёжность и контроль качества

**Цель:** сделать процесс безопасным для продакшна.

Задачи:
1. **Smoke‑checks** после деплоя:
   - health‑endpoint,
   - список модулей,
   - проверка миграций.
2. **Rollback** по `release_id` (политика хранения N релизов).
3. **Аудит‑лог** изменений манифеста (кто, когда, зачем).

Результат: **управляемый и безопасный цикл релизов**.

## 3) Детальные артефакты (что нужно создать)

- `modules.toml` (или аналог) — манифест.
- Отдельный репозиторий‑каталог модулей (marketplace), который содержит список
  доступных модулей и их метаданные в формате TOML (см. раздел 6).
- Генератор реестра (скрипт/xtask).
- Build‑service (job runner + хранение статусов).
- Админ‑API и UI.
- Документация для ops (pipeline + rollback).

## 4) Риски и способы смягчения

- **Долгая сборка** → показывать прогресс и статус, хранить логи.
- **Неудачная сборка** → не деплоить автоматически, требовать ручного деплоя.
- **Сломанный модуль** → проверка совместимости/версий в manifest lint.

## 5) Предлагаемая последовательность внедрения (минимальный MVP)

1. Манифест + генерация реестра (этап A).
2. Минимальный Build‑Service + CLI (этап B).
3. Админка + RBAC (этап C).
4. Rollback + мониторинг (этап D).

## 6) Marketplace модулей (репозиторий со списком)

Чтобы админка могла показывать **каталог модулей**, нужен отдельный репозиторий
со списком доступных модулей. Формат — TOML, чтобы быть совместимым с
`modules.toml` и легко парситься в Rust.

### 6.1 Формат каталога (пример `marketplace.toml`)

```toml
schema = 1
updated_at = "2026-02-01T12:00:00Z"

[modules.content]
slug = "content"
name = "Content"
description = "Base CMS module"
source = "crates-io"
crate = "rustok-content"
version = "0.1"
tags = ["cms", "core"]

[modules.forum]
slug = "forum"
name = "Forum"
description = "Forum module built on content"
source = "git"
crate = "rustok-forum"
git = "ssh://git/forum.git"
rev = "abc123"
tags = ["community"]
```

### 6.2 Поля каталога

| Поле | Тип | Обязательное | Описание |
| --- | --- | --- | --- |
| `schema` | int | да | Версия формата каталога. |
| `updated_at` | string | нет | Время последнего обновления. |
| `modules.*.slug` | string | да | Идентификатор модуля. |
| `modules.*.name` | string | да | Человеческое имя. |
| `modules.*.description` | string | нет | Описание. |
| `modules.*.source` | string | да | `crates-io` \| `git` \| `path`. |
| `modules.*.crate` | string | да | Имя crate. |
| `modules.*.version` | string | нет | Версия (для `crates-io`). |
| `modules.*.git` | string | нет | URL git‑репозитория. |
| `modules.*.rev` | string | нет | Commit SHA/тег. |
| `modules.*.tags` | array | нет | Категории/теги в UI. |

### 6.3 Как это используется

1. Админка скачивает `marketplace.toml` из репозитория каталога.
2. UI отображает список модулей (по тегам/поиску).
3. При выборе модуля админка **подставляет его spec** в `modules.toml`.
4. Дальше запускается rebuild по стандартному сценарию (манифест → build).

### 6.4 Пакеты для UI (admin + storefront)

Для маркетплейса предполагается, что **каждый сторонний модуль** состоит минимум
из трёх частей:

1. **Серверный модуль** (Rust crate) — ядро бизнес-логики и API.
2. **Пакет для админки**:
   - `apps/next-admin`: npm‑пакет.
   - `apps/admin`: Cargo‑crate/библиотека (Leptos UI).
3. **Пакет для фронтенда (витрины)**:
   - `apps/next-frontend`: npm‑пакет.
   - `apps/storefront`: Cargo‑crate/библиотека (Leptos UI).

Идея: если модуль **не подключён в манифест**, то его UI‑пакеты не попадают
в сборку; если подключён — сборка автоматически тянет нужные UI‑пакеты вместе
с серверной частью.

### 6.4.1 Эталонная реализация модуля (полная версия с таблицами)

Чтобы сторонние разработчики могли повторять процесс без догадок, нужен
**эталонный модуль** с максимально полным набором частей: server + admin UI +
storefront UI. В качестве образца стоит взять **самый полный серверный модуль**
— то есть с таблицами, миграциями, CRUD, событиями и настройками.

Рекомендуемый состав и структура (монорепо‑формат, всё в одной папке модуля):

```
modules/rustok-catalog/
├─ crates/
│  ├─ catalog-server/          # Rust crate: таблицы, сущности, сервисы, GraphQL/REST
│  ├─ catalog-migrations/      # Rust crate: миграции SeaORM
│  └─ catalog-events/          # Rust crate: доменные события (если выделяются отдельно)
├─ admin/
│  ├─ next/                    # npm пакет для apps/next-admin
│  └─ leptos/                  # Rust crate для apps/admin (Leptos UI)
├─ storefront/
│  ├─ next/                    # npm пакет для apps/next-frontend
│  └─ leptos/                  # Rust crate для apps/storefront (Leptos UI)
├─ module.toml                 # metadata/compatibility для marketplace
└─ README.md                   # краткая инструкция по локальной сборке/тестам
```

Минимальный функционал в эталонном серверном модуле:
- **Таблицы и миграции** (SeaORM), валидный MigrationSource.
- **Entities/DTO/Services** для CRUD.
- **События** (event publish) + outbox/transport.
- **Регистрация в ModuleRegistry** и зависимости.
- **Настройки модуля** (settings payload + schema).
- **API слой**: GraphQL/REST контракты для UI‑пакетов.
- **Сквозной пример фичи**: одна сущность, которая проходит через API → UI →
  сохранение → события (чтобы быстро понять end‑to‑end поток).
- **Готовые шаблоны** для UI‑пакетов (Leptos + Next): формы, списки, empty‑state.
- **Быстрый старт**: короткий чек‑лист (создать/переименовать модуль, обновить
  manifest, запустить локальную сборку).

Дополнительно, чтобы модуль был максимально полезен внешним разработчикам:
- **Документация по структуре**: где менять схему БД, где API, где UI.
- **Минимальные тестовые сценарии** (ручные steps): без отдельной папки тестов,
  но с чёткими шагами проверки для локального окружения.
- **Локальный DX/скрипты**: набор команд для запуска server/admin/storefront в
  dev‑режиме, единая точка входа (Makefile/justfile) и пример `.env`.
- **Демо‑данные**: сиды для быстрой проверки UI и энд‑ту‑энд флоу.
- **Контракт версий**: правила совместимости server/admin/storefront и пример
  диапазонов (semver/compat section).
- **Схема `module.toml`**: явные поля для server/admin/storefront пакетов,
  чтобы сборка могла детерминированно подтянуть все части.
- **Публикация и релиз**: как выпускать модуль (теги/версии), и как сборка
  выбирает нужную версию из marketplace.
- **Миграции**: как модуль подключает MigrationSource и когда миграции
  исполняются в пайплайне (build/deploy).
- **RBAC для UI**: стандартные guard-правила для админки/витрины.
- **Event contract**: минимальный набор метаданных в событиях для совместимости
  со шиной и read-моделями.
- **Observability**: метрики/логи/трейсы и минимальный dashboard для модуля.
- **I18n/локализация**: правила для строк UI и переводов.
- **Security‑практики**: обработка прав, валидация входных данных, запреты на
  небезопасные операции в фоне/скриптах.

Задача эталонного модуля — показать полный end‑to‑end путь:
manifest → registry → UI‑пакеты → build → deploy.
Это критично для внешних разработчиков и для маркетплейса.

### 6.5 Надёжный механизм установки и сборки по команде бэкенда

Цель — сделать **детерминированный** и **безопасный** контур, где бэкенд
отдаёт команду “установить/удалить модуль”, а сборочная система выполняет её
через воспроизводимый пайплайн.

Минимальный набор компонентов:
1. **Admin API в бэкенде** (`apps/server`):
   - принимает запрос на install/uninstall,
   - сохраняет изменённый `modules.toml`,
   - создаёт запись `builds` со статусом `queued`,
   - публикует событие `BuildRequested`.
2. **Build‑orchestrator** (отдельный сервис или job‑runner):
   - подписан на `BuildRequested`,
   - забирает `modules.toml` (или `manifest_ref`),
   - выполняет **locked** сборку.
3. **Locked‑сборка** (без сетевой импровизации):
   - `cargo build --locked` для Rust‑части,
   - `npm ci`/`pnpm install --frozen-lockfile` для npm‑части,
   - сборочные артефакты фиксируются хэшами.
4. **Deploy‑шаг** (atomic):
   - выкатывается новый образ/релиз,
   - health‑checks,
   - обновление статуса build в бэкенде.
5. **Rollback‑путь**:
   - хранить N релизов,
   - быстрый откат на последний стабильный `release_id`.

Дополнительно для надёжности:
- **Единый “source of truth”** — `modules.toml` + lockfiles (Cargo.lock, pnpm‑lock).
- **Аудит**: кто запросил сборку, какие изменения в манифесте.
- **Гарантия идемпотентности**: повторный BuildRequested с тем же hash не запускает
  новую сборку, а возвращает уже готовый результат.

### 6.6 Предложения для дальнейшей реализации

1. **Module registry API для фронтенда/админки**:
   - эндпойнт, который возвращает список активных модулей и их версии;
   - UI скрывает/показывает функциональность на основании ответа.
2. **Изоляция build‑runner**:
   - сборка в отдельном контейнере;
   - ограничение сети (только registry);
   - подпись артефактов и проверка целостности.
3. **Проверки совместимости**:
   - связка версий server‑модуля ↔ UI‑пакетов;
   - preflight‑валидация перед запуском сборки.

---

Если нужно, следующий шаг — разложить эти этапы в задачи по репозиторию
(`apps/server`, `apps/admin`, `docs`, `CI`) и оценить трудозатраты.

This is an alpha version and requires clarification. Be careful, there may be errors in the text. So that no one thinks that this is an immutable rule.
