# План реализации пересборки модулей (с учетом текущей архитектуры)

Этот документ — практический план внедрения **WordPress/NodeBB‑стиля** для
модулей RusToK, где **install/uninstall = изменение манифеста → rebuild →
deploy**. План учитывает текущую архитектуру: модульный реестр формируется на
старте сервера, модули — Rust‑crates, а приложение уже содержит админ‑интерфейсы
(`apps/admin`, `apps/next-admin`).

## 0) Текущие реалии (от чего отталкиваемся)

- **Модули компилируются в бинарник**, а `ModuleRegistry` строится при старте
  сервера. Это означает, что установка “нового” модуля без сборки невозможна —
  требуется новый артефакт сборки.
- **Включение/выключение** модуля на tenant‑уровне уже решено через
  `tenant_modules` и `toggle_module` (runtime‑логика), но это не меняет набор
  модулей в бинарнике.
- Уже есть документация по **манифесту** и **admin rebuild blueprint** —
  это основа для формализации процесса пересборки и API‑интеграций.

## 1) Цели внедрения (что должно работать)

1. **Install/uninstall через админку**: админ изменяет список модулей,
   запускает сборку, видит статус и может откатиться.
2. **Источник правды** — `modules.toml` (или иной manifest), зафиксированный
   в репозитории/артефакте сборки.
3. **Сборка и деплой** происходят автоматически и воспроизводимо.
4. **Никакой runtime‑подгрузки нативного кода**, только пересборка.

## 2) Предлагаемая дорожная карта

### Этап A — Формализовать манифест и связать его с кодом

**Цель:** чтобы набор модулей *фактически* определялся манифестом.

Задачи:
1. **Выбрать файл манифеста** (например, `modules.toml`) и утвердить схему
   на уровне команды (ссылаться на спецификацию).
2. **Автоматизировать сборку реестра**:
   - добавить `xtask`/`build.rs`/скрипт, который генерирует код регистрации
     модулей на основе манифеста (например, `apps/server/src/modules/generated.rs`).
   - `build_registry()` импортирует сгенерированный список вместо
     “ручной” регистрации.
3. **Проверка на этапе CI**: если манифест изменился, а сгенерированный код
   не обновлён — билд должен падать.

Результат: **манифест становится единственным источником набора модулей.**

### Этап B — Минимальный Build‑Service (без админки)

**Цель:** дать команде способ запускать rebuild без UI, но с логами и статусом.

Задачи:
1. **Сервис‑обёртка** (отдельный сервис или job runner), который:
   - принимает `modules.toml` (или ссылку на git‑коммит),
   - запускает сборку,
   - публикует артефакт/образ,
   - сохраняет статус/логи.
2. **Минимальная модель данных** (таблица `builds` или внешнее хранилище):
   - `build_id`, `status`, `manifest_hash`, `started_at`, `finished_at`,
     `logs_url`, `release_id`.
3. **CLI/HTTP API** для запуска и статуса (достаточно пары эндпойнтов,
   как в blueprint).

Результат: **сборку можно запускать вручную/скриптом**, не дожидаясь UI.

### Этап C — Интеграция с админкой (NodeBB‑подобный UX)

**Цель:** UI‑кнопка “Install/Uninstall” с прогрессом сборки и деплоя.

Задачи:
1. **Admin API** (в `apps/server`) для:
   - создания rebuild‑задачи,
   - чтения статуса,
   - запуска deploy/rollback.
2. **UI в админке** (`apps/admin` или `apps/next-admin`):
   - управление списком модулей (manifest),
   - модальное окно статуса сборки,
   - история сборок/релизов.
3. **RBAC**: только админы/суперадмины могут запускать rebuild.

Результат: **полный “NodeBB‑подобный” опыт** — управляемые пересборки из UI.

### Этап D — Надёжность и контроль качества

**Цель:** сделать процесс безопасным для продакшна.

Задачи:
1. **Smoke‑checks** после деплоя:
   - health‑endpoint,
   - список модулей,
   - проверка миграций.
2. **Rollback** по `release_id` (политика хранения N релизов).
3. **Аудит‑лог** изменений манифеста (кто, когда, зачем).

Результат: **управляемый и безопасный цикл релизов**.

## 3) Детальные артефакты (что нужно создать)

- `modules.toml` (или аналог) — манифест.
- Отдельный репозиторий‑каталог модулей (marketplace), который содержит список
  доступных модулей и их метаданные в формате TOML (см. раздел 6).
- Генератор реестра (скрипт/xtask).
- Build‑service (job runner + хранение статусов).
- Админ‑API и UI.
- Документация для ops (pipeline + rollback).

## 4) Риски и способы смягчения

- **Долгая сборка** → показывать прогресс и статус, хранить логи.
- **Неудачная сборка** → не деплоить автоматически, требовать ручного деплоя.
- **Сломанный модуль** → проверка совместимости/версий в manifest lint.

## 5) Предлагаемая последовательность внедрения (минимальный MVP)

1. Манифест + генерация реестра (этап A).
2. Минимальный Build‑Service + CLI (этап B).
3. Админка + RBAC (этап C).
4. Rollback + мониторинг (этап D).

## 6) Marketplace модулей (репозиторий со списком)

Чтобы админка могла показывать **каталог модулей**, нужен отдельный репозиторий
со списком доступных модулей. Формат — TOML, чтобы быть совместимым с
`modules.toml` и легко парситься в Rust.

### 6.1 Формат каталога (пример `marketplace.toml`)

```toml
schema = 1
updated_at = "2026-02-01T12:00:00Z"

[modules.content]
slug = "content"
name = "Content"
description = "Base CMS module"
source = "crates-io"
crate = "rustok-content"
version = "0.1"
tags = ["cms", "core"]

[modules.forum]
slug = "forum"
name = "Forum"
description = "Forum module built on content"
source = "git"
crate = "rustok-forum"
git = "ssh://git/forum.git"
rev = "abc123"
tags = ["community"]
```

### 6.2 Поля каталога

| Поле | Тип | Обязательное | Описание |
| --- | --- | --- | --- |
| `schema` | int | да | Версия формата каталога. |
| `updated_at` | string | нет | Время последнего обновления. |
| `modules.*.slug` | string | да | Идентификатор модуля. |
| `modules.*.name` | string | да | Человеческое имя. |
| `modules.*.description` | string | нет | Описание. |
| `modules.*.source` | string | да | `crates-io` \| `git` \| `path`. |
| `modules.*.crate` | string | да | Имя crate. |
| `modules.*.version` | string | нет | Версия (для `crates-io`). |
| `modules.*.git` | string | нет | URL git‑репозитория. |
| `modules.*.rev` | string | нет | Commit SHA/тег. |
| `modules.*.tags` | array | нет | Категории/теги в UI. |

### 6.3 Как это используется

1. Админка скачивает `marketplace.toml` из репозитория каталога.
2. UI отображает список модулей (по тегам/поиску).
3. При выборе модуля админка **подставляет его spec** в `modules.toml`.
4. Дальше запускается rebuild по стандартному сценарию (манифест → build).

---

Если нужно, следующий шаг — разложить эти этапы в задачи по репозиторию
(`apps/server`, `apps/admin`, `docs`, `CI`) и оценить трудозатраты.

This is an alpha version and requires clarification. Be careful, there may be errors in the text. So that no one thinks that this is an immutable rule.
