ФИНАЛЬНАЯ МАТРИЦА ИНТЕРНЕТ-МАГАЗИНА

Архитектура: 5 доменов + 2 фундаментальных слоя (Cross-cutting)

0) Два фундаментальных слоя (сквозные, обслуживают все домены)
A. Infrastructure Core (сквозная инфраструктура)

Правила, связи, медиа/SEO, локализация, аудит, события, нотификации — всё то, что переиспользуется любым доменом.

Реализация через композицию, полиморфные ссылки, доменные сервисы, shared-kernel (аккуратно).

B. Experience & Integration Layer (слой опыта и интеграций)

API (REST/GraphQL), витрины, BFF, интеграции с платежами/доставкой/1С/ERP, поисковый индекс, очереди, webhooks.

Это слой оркестрации и представления, не содержащий “ядра” доменных правил.

Далее — доменная матрица (I–VI). Внутри раздела I перечислены ключевые инфраструктурные сервисы из исходной матрицы + минимально необходимые “продовые” дополнения (без ломки структуры).

I. ИНФРАСТРУКТУРНЫЙ СЛОЙ (Infrastructure Core)
1) Rule Engine (Движок Правил)

Универсальная логика “Если → То”, применимая в маркетинге, доставке, налогах, сегментации, бонусах.

Condition (Условие)
Context (Cart/Order/Customer/Product/Date/Geo/Channel) + Operator + Value
Примеры контекстов: сумма корзины, вес, категория клиента, дата, валюта, склад, регион.

Action (Действие)
Type + Value (+ optional params)
Типы: скидка, наценка, налог, бесплатная доставка, бонусы, выдача сегмента, блокировка способа оплаты, gift.

Применение (must-have)

Marketing/Promotions: “Если сумма > 1000 → -10%”

Shipping: “Если вес > 10кг → +500”

Customer segmentation: “Если заказов > 5 → VIP”

B2B: правила цен/скидок по компании/договору

Технические требования

Приоритеты правил, стоп-условия, возможность комбинирования (AND/OR)

Режимы: preview (расчет) и apply (применение)

Версионирование/черновики/публикация, аудит изменений

2) Relation Engine (Движок Связей)

Универсальные связи “многие-ко-многим” между любыми сущностями, без жестких таблиц на каждый кейс.

Relation

Source (Type, ID) ↔ Target (Type, ID)

Metadata

RelationType (cross-sell, up-sell, аналог, аксессуар, “входит в комплект”, “совместимо с”…)

Priority/Weight, IsBidirectional, ValidFrom/To (опционально)

Применение

товар↔товар (рекомендации), категория↔баннер, клиент↔сегмент, страница CMS↔категория и т.п.

3) Media & SEO (Представление)

Единый сервис для медиа-ресурсов и SEO-метаданных во всех доменах (каталог, CMS, бренды и т.д.)

Media Asset

файл/URL, тип (photo/video/doc), набор версий (thumb/full/zoom), сортировка

Alt, Title, автор/лицензия (если нужно)

SEO Metadata

Slug (URL), Title, Description, Robots, Canonical, OG tags, schema.org (опционально)

Требования

уникальность slug в рамках Store/Channel

301/302 редиректы при смене slug (опционально, но очень желательно)

4) (Рекомендуемое инфраструктурное дополнение) Localization & Money

Чтобы не “размазать” по доменам:

Мультивалюта (Money: amount + currency), курсы, округления

Мультиязык (resource keys, fallback, per-store language)

5) (Рекомендуемое инфраструктурное дополнение) Audit / RBAC / Events

Аудит: кто/что/когда изменил (особенно цены, остатки, правила)

RBAC: роли, права (admin backoffice, оператор склада, контент-менеджер)

Доменные события: OrderPlaced, StockReserved, PriceChanged → для интеграций/нотификаций/индекса

II. ДОМЕН: КАТАЛОГ (Catalog Domain)

Центральная ось. Реализует наследование свойств (Virto-style: Catalog → Category → Product → Variant/SKU).

1) Структура данных (мета-уровень)

Attribute Definition
Мета-описание атрибута:
code, type (string/number/bool/dictionary/multi-dictionary/date), label, isFilterable, isRequired, isVariantAxis, validation

Dictionary
Справочники значений: бренд, цвет, материал и т.п.
Поддержка локализации display-имен.

Catalog (Root Node)

корневой контейнер

определяет доступные атрибуты/словари

политика наследования/ограничений (опционально)

2) Иерархия сущностей (наследование)

Category (Node)

Inherits: атрибуты от Catalog (доступность/типизация)

Owns: фасеты/фильтры, SEO, правила мерчандайзинга (опционально)

Relations: дерево parent-child, связи через Relation Engine

Product (Tradeable Item)

Inherits: значения атрибутов от Category (общие значения/дефолты)

Owns: описание, контент, рейтинг, SEO, медиа-галерея

Relations: cross-sell / up-sell / аналоги

Variant / SKU (Tradeable Item)

Inherits: всё от Product

Overrides: уникальные свойства (размер, цвет, вес, штрихкод, упаковка)

Ключевой принцип: продаваемая единица = SKU (Variant)

Практическая норма: цены и остатки привязываются к SKU, а не к “родительскому” Product.

III. ДОМЕН: КОММЕРЦИЯ (Commerce Domain)

Условия продажи: цены + доступность.

1) Pricing (Ценообразование)

Price List

контекст цены: Base, Sale, B2B_Partner, Marketplace, Region, Channel

привязка к валюте (+ возможно к Store)

Price Record

(SKU/Product ID + PriceList ID) → Price

валюта как часть Money или наследуется от прайс-листа

Tiered Price

оптовые уровни: qty >= N → price

может быть частью PriceRecord или отдельной сущностью

Требования

Валидация периода действия (validFrom/validTo) для промо-цен (по необходимости)

Расчет итоговой цены через Rule Engine (скидки/купоны/персональные условия)

2) Inventory (Инвентарь)

Warehouse (Node)

физический склад: address, schedule, зоны/типы (опционально)

Inventory Record

(SKU ID + Warehouse ID) → quantities

Quantity:

OnHand (физически)

Reserved (в заказах/резервах)

Available = OnHand - Reserved (доступно к продаже)

Inventory Movement (Transaction)

история движений: приход, расход, резерв, разрезерв, корректировка

источник: заказ, поставка, ручная операция

Требования

Резервирование при создании заказа/оплаты (стратегия выбирается)

Консистентность (идемпотентность транзакций движений)

IV. ДОМЕН: КЛИЕНТ (Customer Domain)

Субъекты системы: B2C и B2B.

1) Identity / Profile

Account

логин: email/phone, пароль/SSO, роли (минимум для витрины)

Profile (Party)

Personal: ФИО, дата рождения, пол (опционально)

Corporate (B2B): компания, ИНН/КПП, договор/условия (по необходимости)

Address Book

набор Address: доставка, юридический, billing/shipping

2) Активность и взаимодействие

Wallet

баланс: бонусы/депозит/кредиты (если нужно)

Segment

статический или динамический (через Rule Engine)

UGC

отзывы, вопросы: связь Customer ↔ Product/SKU (+ модерация по желанию)

V. ДОМЕН: ЗАКАЗЫ (Order Domain)

Жизненный цикл сделки и фиксация состояния.

1) Документы (Documents)

Cart

временный документ сессии

Order

финальный контракт

Snapshot: фиксирует копии данных клиента и товаров на момент покупки (именно так!)

Shipment

документ отгрузки: warehouse → carrier

Return (RMA)

запрос на возврат, причины, статусы, привязка к Order/Shipment

2) Компоненты документов

Document Line

строка: SKU + qty + unit price + discounts + taxes

Payment Transaction

записи о деньгах: сумма, шлюз, статусы, внешние ID, попытки

Требования

Статус-машина заказа (created/paid/fulfilled/cancelled/refunded…)

Разделение: payment vs fulfillment (оплата ≠ отгрузка)

Возможность частичных отгрузок/возвратов (желательно)

VI. ДОМЕН: ПЛАТФОРМА (Platform Domain)

Контекст витрин, CMS и коммуникации.

Store (Context)

витрина как “контекст”: канал (web/mobile/marketplace), валюта, язык, каталог, настройки налогов/доставки

поддержка multi-store/multi-tenant (если нужно)

CMS

Page: статические страницы (иерархия)

Menu: навигационные деревья

связь CMS ↔ Catalog через Relation Engine (баннеры, подборки, лендинги)

Notification

шаблоны email/SMS/push + очередь отправки

триггеры часто идут из Order/Customer событий

ПРИМЕР “МАТРЁШКИ” (НАСЛЕДОВАНИЕ ДАННЫХ)
Уровень	Сущность	Что делает с атрибутами	Пример данных
1	Catalog	Определяет доступные атрибуты/словари	“Цвет”, “Материал”, “Бренд”
2	Category	Задает общие значения/дефолты (и фасеты)	Категория “Футболки”: Материал = “Хлопок”
3	Product	Наследует общие + добавляет свои	Product “Polo”: Материал (наслед.), Бренд = “Nike”
4	Variant / SKU	Наследует всё + переопределяет уникальное	SKU “Polo Red M”: Цвет = “Red”, Размер = “M”
Критерии “готово к разработке” (чек-лист архитектора)

Везде, где нужно, используется Rule Engine (промо/доставка/сегменты/налоги).

Все “произвольные” связи делаются через Relation Engine, без зоопарка таблиц.

Цены и остатки проектируются минимум на уровне SKU + (PriceList/Warehouse).

Order Snapshot обязателен (иначе исторические заказы ломаются при изменении каталога).

Store Context задаёт канал/язык/валюту/каталог, и всё это работает в multi-store режиме.
