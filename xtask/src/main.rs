use anyhow::{Context, Result};
use serde::Deserialize;
use std::collections::HashMap;
use std::fs;
use std::path::Path;

/// Module manifest structure
#[derive(Debug, Deserialize)]
struct Manifest {
    schema: u32,
    #[allow(dead_code)]
    app: String,
    #[allow(dead_code)]
    build: Option<BuildConfig>,
    modules: HashMap<String, ModuleSpec>,
    #[allow(dead_code)]
    settings: Option<Settings>,
}

#[derive(Debug, Deserialize)]
struct BuildConfig {
    #[allow(dead_code)]
    target: Option<String>,
    #[allow(dead_code)]
    profile: Option<String>,
    #[allow(dead_code)]
    deployment_profile: Option<String>,
}

#[derive(Debug, Deserialize)]
struct ModuleSpec {
    #[serde(rename = "crate")]
    crate_name: String,
    source: String,
    #[allow(dead_code)]
    path: Option<String>,
    #[allow(dead_code)]
    version: Option<String>,
    #[allow(dead_code)]
    git: Option<String>,
    #[allow(dead_code)]
    rev: Option<String>,
    #[allow(dead_code)]
    features: Option<Vec<String>>,
}

#[derive(Debug, Deserialize)]
struct Settings {
    #[allow(dead_code)]
    default_enabled: Option<Vec<String>>,
}

fn main() -> Result<()> {
    let args: Vec<String> = std::env::args().collect();
    
    if args.len() < 2 {
        print_usage();
        return Ok(());
    }

    match args[1].as_str() {
        "generate-registry" => generate_registry()?,
        "validate-manifest" => validate_manifest()?,
        "list-modules" => list_modules()?,
        _ => {
            eprintln!("Unknown command: {}", args[1]);
            print_usage();
            std::process::exit(1);
        }
    }

    Ok(())
}

fn print_usage() {
    println!("Usage: cargo xtask <command>");
    println!();
    println!("Commands:");
    println!("  generate-registry   Generate ModuleRegistry from modules.toml");
    println!("  validate-manifest   Validate modules.toml schema");
    println!("  list-modules        List all configured modules");
}

fn load_manifest() -> Result<Manifest> {
    let content = fs::read_to_string("modules.toml")
        .context("Failed to read modules.toml")?;
    let manifest: Manifest = toml::from_str(&content)
        .context("Failed to parse modules.toml")?;
    
    if manifest.schema != 1 {
        anyhow::bail!("Unsupported manifest schema: {}", manifest.schema);
    }
    
    Ok(manifest)
}

fn generate_registry() -> Result<()> {
    println!("Generating ModuleRegistry from modules.toml...");
    
    let manifest = load_manifest()?;
    let output_path = Path::new("apps/server/src/modules/generated.rs");
    
    // Ensure directory exists
    fs::create_dir_all(output_path.parent().unwrap())
        .context("Failed to create modules directory")?;
    
    let mut code = String::new();
    code.push_str("// AUTO-GENERATED by `cargo xtask generate-registry`\n");
    code.push_str("// DO NOT EDIT MANUALLY\n");
    code.push_str("// Generated from modules.toml\n\n");
    code.push_str("use rustok_core::ModuleRegistry;\n\n");
    
    // Generate imports
    for (slug, spec) in &manifest.modules {
        let module_struct = to_pascal_case(slug);
        let crate_name = spec.crate_name.replace("-", "_");
        code.push_str(&format!(
            "use {}::{}Module;\n",
            crate_name, module_struct
        ));
    }
    
    code.push_str("\n/// Build ModuleRegistry from configured modules\n");
    code.push_str("pub fn build_registry() -> ModuleRegistry {\n");
    code.push_str("    let mut registry = ModuleRegistry::new();\n\n");
    
    // Register modules
    for (slug, _spec) in &manifest.modules {
        let module_struct = to_pascal_case(slug);
        code.push_str(&format!(
            "    // Register {} module\n",
            slug
        ));
        code.push_str(&format!(
            "    registry.register(Box::new({}Module::new()));\n\n",
            module_struct
        ));
    }
    
    code.push_str("    registry\n");
    code.push_str("}\n");
    
    fs::write(output_path, code)
        .context("Failed to write generated.rs")?;
    
    println!("✓ Generated: {}", output_path.display());
    println!("  Registered {} modules", manifest.modules.len());
    
    Ok(())
}

fn validate_manifest() -> Result<()> {
    println!("Validating modules.toml...");
    
    let manifest = load_manifest()?;
    
    // Validate module specs
    for (slug, spec) in &manifest.modules {
        match spec.source.as_str() {
            "path" => {
                if spec.path.is_none() {
                    anyhow::bail!("Module '{}' has source='path' but no path specified", slug);
                }
            }
            "git" => {
                if spec.git.is_none() {
                    anyhow::bail!("Module '{}' has source='git' but no git URL specified", slug);
                }
            }
            "crates-io" => {
                if spec.version.is_none() {
                    anyhow::bail!("Module '{}' has source='crates-io' but no version specified", slug);
                }
            }
            other => {
                anyhow::bail!("Module '{}' has invalid source: {}", slug, other);
            }
        }
    }
    
    println!("✓ Manifest is valid");
    println!("  Schema: {}", manifest.schema);
    println!("  Modules: {}", manifest.modules.len());
    
    Ok(())
}

fn list_modules() -> Result<()> {
    let manifest = load_manifest()?;
    
    println!("Configured modules:");
    println!();
    
    for (slug, spec) in &manifest.modules {
        println!("  {}:", slug);
        println!("    crate: {}", spec.crate_name);
        println!("    source: {}", spec.source);
        if let Some(ref path) = spec.path {
            println!("    path: {}", path);
        }
        if let Some(ref version) = spec.version {
            println!("    version: {}", version);
        }
        if let Some(ref features) = spec.features {
            println!("    features: {:?}", features);
        }
        println!();
    }
    
    Ok(())
}

fn to_pascal_case(s: &str) -> String {
    s.split('-')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + &chars.as_str().to_lowercase(),
            }
        })
        .collect()
}
